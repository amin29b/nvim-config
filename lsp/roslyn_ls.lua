-- local M = {}
--
-- local uv = vim.uv
-- local fs = vim.fs
-- local configs = {}
--
-- M.name = "roslyn_ls"
-- M.offset_encoding = 'utf-8'
-- M.cmd = {
--     -- 'Microsoft.CodeAnalysis.LanguageServer',
--     -- '--logLevel',
--     -- 'Information',
--     -- '--extensionLogDirectory',
--     -- fs.joinpath(uv.os_tmpdir(), 'roslyn_ls/logs'),
--     -- '--stdio',
-- }
--
-- local function get_configs_from_sln(sln)
--     -- local configs = {}
--     for line in io.lines(sln) do
--         local cfg = line:match("^%s*(%w+)|AnyCPU =")
--         if cfg then
--             configs[cfg] = true
--         end
--     end
--     return vim.tbl_keys(configs)
-- end
--
-- local function select_build_config(callback)
--
--     -- local configs = get_configs_from_sln()
--     -- local configs =
--     -- {
--     --     "RIGHTEL_DEBUG"
--     --     , "RIGHTEL_RELEASE"
--     -- } -- put your custom ones here
--
--     vim.ui.select(configs, {
--         prompt = "Select build configuration:",
--     }, function(choice)
--         if not choice then
--             return
--         end
--         callback(choice)
--     end)
-- end
--
-- local function get_env()
--     local configuration = ""
--     local platform = "AnyCPU"
--     select_build_config(function(config)
--         configuration = config
--     end)
--
--     return {
--         Configuration = configuration,
--         Platform = platform,
--     }
-- end
--
-- M.filetypes = { 'cs' }
--
--
-- local function on_init_sln(client, target)
--     get_configs_from_sln(target)
--     vim.notify('Initializing: ' .. target, vim.log.levels.TRACE, { title = 'roslyn_ls' })
--     ---@diagnostic disable-next-line: param-type-mismatch
--     client:notify('solution/open', {
--         solution = vim.uri_from_fname(target),
--     })
-- end
--
-- local function on_init_project(client, project_files)
--     vim.notify('Initializing: projects', vim.log.levels.TRACE, { title = 'roslyn_ls' })
--     ---@diagnostic disable-next-line: param-type-mismatch
--     client:notify('project/open', {
--         projects = vim.tbl_map(function(file)
--             return vim.uri_from_fname(file)
--         end, project_files),
--     })
-- end
--
-- local function roslyn_handlers()
--     return {
--         ["textDocument/publishDiagnostics"] = vim.lsp.with(
--             vim.lsp.diagnostic.on_publish_diagnostics, {
--                 virtual_text = false,
--                 signs = true,
--                 underline = true,
--                 update_in_insert = false,
--             }),
--         ['workspace/projectInitializationComplete'] = function(_, _, ctx)
--             vim.notify('Roslyn project initialization complete', vim.log.levels.INFO, { title = 'roslyn_ls' })
--
--             local buffers = vim.lsp.get_buffers_by_client_id(ctx.client_id)
--             local client = assert(vim.lsp.get_client_by_id(ctx.client_id))
--             for _, buf in ipairs(buffers) do
--                 client:request(vim.lsp.protocol.Methods.textDocument_diagnostic, {
--                     textDocument = vim.lsp.util.make_text_document_params(buf),
--                 }, nil, buf)
--             end
--         end,
--         ['workspace/_roslyn_projectHasUnresolvedDependencies'] = function()
--             vim.notify('Detected missing dependencies. Run `dotnet restore` command.', vim.log.levels.ERROR, {
--                 title = 'roslyn_ls',
--             })
--             return vim.NIL
--         end,
--         ['workspace/_roslyn_projectNeedsRestore'] = function(_, result, ctx)
--             local client = assert(vim.lsp.get_client_by_id(ctx.client_id))
--
--             ---@diagnostic disable-next-line: param-type-mismatch
--             client:request('workspace/_roslyn_restore', result, function(err, response)
--                 if err then
--                     vim.notify(err.message, vim.log.levels.ERROR, { title = 'roslyn_ls' })
--                 end
--                 if response then
--                     for _, v in ipairs(response) do
--                         vim.notify(v.message, vim.log.levels.INFO, { title = 'roslyn_ls' })
--                     end
--                 end
--             end)
--
--             return vim.NIL
--         end,
--         ['razor/provideDynamicFileInfo'] = function(_, _, _)
--             vim.notify(
--                 'Razor is not supported.\nPlease use https://github.com/tris203/rzls.nvim',
--                 vim.log.levels.WARN,
--                 { title = 'roslyn_ls' }
--             )
--             return vim.NIL
--         end,
--     }
-- end
--
--
--
--
-- local function roslyn_settings()
--     return {
--         ["csharp|solution"] = {
--             loadProjectsOnDemand = false,
--         },
--         ['csharp|background_analysis'] = {
--             dotnet_analyzer_diagnostics_scope = 'OpenFiles',
--             dotnet_compiler_diagnostics_scope = 'CurrentDocument',
--         },
--         ['csharp|inlay_hints'] = {
--             csharp_enable_inlay_hints_for_implicit_object_creation = false,
--             csharp_enable_inlay_hints_for_implicit_variable_types = false,
--             csharp_enable_inlay_hints_for_lambda_parameter_types = false,
--             csharp_enable_inlay_hints_for_types = false,
--             dotnet_enable_inlay_hints_for_indexer_parameters = false,
--             dotnet_enable_inlay_hints_for_literal_parameters = false,
--             dotnet_enable_inlay_hints_for_object_creation_parameters = false,
--             dotnet_enable_inlay_hints_for_other_parameters = false,
--             dotnet_enable_inlay_hints_for_parameters = false,
--             dotnet_suppress_inlay_hints_for_parameters_that_differ_only_by_suffix = false,
--             dotnet_suppress_inlay_hints_for_parameters_that_match_argument_name = false,
--             dotnet_suppress_inlay_hints_for_parameters_that_match_method_intent = false,
--         },
--         ['csharp|symbol_search'] = {
--             dotnet_search_reference_assemblies = false,
--         },
--         ['csharp|completion'] = {
--             dotnet_show_name_completion_suggestions = false,
--             dotnet_show_completion_items_from_unimported_namespaces = false,
--             dotnet_provide_regex_completions = false,
--         },
--         ['csharp|code_lens'] = {
--             dotnet_enable_references_code_lens = false,
--         },
--     }
-- end
--
-- M.capabilities = {
--     -- HACK: Doesn't show any diagnostics if we do not set this to true
--     textDocument = {
--         diagnostic = {
--             dynamicRegistration = true,
--         },
--     },
-- }
--
-- M.filewatching = true
--
-- M.handlers = roslyn_handlers()
-- M.settings = roslyn_settings()
--
-- M.root_dir = function(bufnr, cb)
--     local bufname = vim.api.nvim_buf_get_name(bufnr)
--     -- don't try to find sln or csproj for files from libraries
--     -- outside of the project
--     if not bufname:match('^' .. fs.joinpath('/tmp/MetadataAsSource/')) then
--         -- try find solutions root first
--         local root_dir = fs.root(bufnr, function(fname, _)
--             return fname:match('%.sln[x]?$') ~= nil
--         end)
--
--         if not root_dir then
--             -- try find projects root
--             root_dir = fs.root(bufnr, function(fname, _)
--                 return fname:match('%.csproj$') ~= nil
--             end)
--         end
--
--         if root_dir then
--             cb(root_dir)
--         end
--     end
-- end
--
-- M.on_init = {
--     function(client)
--         local root_dir = client.config.root_dir
--
--         -- try load first solution we find
--         for entry, type in fs.dir(root_dir) do
--             if type == 'file' and (vim.endswith(entry, '.sln') or vim.endswith(entry, '.slnx')) then
--                 on_init_sln(client, fs.joinpath(root_dir, entry))
--                 return
--             end
--         end
--
--         -- if no solution is found load project
--         for entry, type in fs.dir(root_dir) do
--             if type == 'file' and vim.endswith(entry, '.csproj') then
--                 on_init_project(client, { fs.joinpath(root_dir, entry) })
--             end
--         end
--     end,
-- }
--
-- M.cmd_env = get_env()
-- return M
